{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/comlink/dist/esm/comlink.mjs","webpack:///./node_modules/object-mapper/index.js","webpack:///./node_modules/object-mapper/src/object-mapper.js","webpack:///./src/entity.ts","webpack:///./src/gurps/resources/trait.ts","webpack:///./src/gurps/workerscripts/trait.worker.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,kBAAkB,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA,yDAAyD,eAAe,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsH;AACtH;;;;;;;;;;;;;AC1Sa;AACb;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,mBAAO,CAAC,8EAAqB,E;;;;;;;;;;;;AC7BjC;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,kEAAkE,QAAQ;AAC1E,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChdsC;AAuB/B,MAAM,MAAM;IAGf,YAAY,KAAQ,EAAE,IAAQ;QAF9B;;;;;WAAQ;QA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","file":"workers/trait-worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/gurps/workerscripts/trait.worker.ts\");\n","/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case 0 /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case 1 /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case 2 /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case 3 /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case 4 /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case 5 /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === 5 /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: 5 /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: 0 /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: 1 /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: 4 /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 2 /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 3 /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: 3 /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: 0 /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case 3 /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case 0 /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","'use strict';\n/*\n\n The MIT License (MIT)\n =====================\n\n Copyright (c) 2012 Daniel L. VerWeire\n\n Permission is hereby granted, free of charge, to any person obtaining\n a copy of this software and associated documentation files (the\n \"Software\"), to deal in the Software without restriction, including\n without limitation the rights to use, copy, modify, merge, publish,\n distribute, sublicense, and/or sell copies of the Software, and to\n permit persons to whom the Software is furnished to do so, subject to\n the following conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n */\n\nmodule.exports = require('./src/object-mapper');","'use strict';\n\nvar _undefined\n\n/**\n * Map a object to another using the passed map\n * @param src\n * @param [dest]\n * @param [map]\n * @returns {*}\n * @constructor\n */\n\nfunction ObjectMapper(src, dest, map)\n{\n  // There are two different constructors - move around properties if needed\n  // e.g (ObjectMapper(from,map))\n  if (typeof map === 'undefined') {\n    map = dest\n    dest = _undefined\n  }\n\n  // Loop through the map to process individual mapping instructions\n  for (const srckey in map) {\n    const destkey = map[srckey]\n    // Extract the data from the source object or array\n    const data = getKeyValue(src, srckey)\n    // Build an object with all of these parameters in case custom transform or default functions need them to derive their values\n    let context = {src: src, srckey: srckey, destkey: destkey}\n    // Set the data into the destination object or array format\n    dest = setKeyValue(dest, destkey, data, context)\n  }\n\n  return dest\n}\n\n// A string of how to navigate through the incoming array is sent.\n// This is translated into an array of instructions for the recursive object\nfunction getKeyValue(src, keystr)\n{\n  // Parse the source key string into an array/object format that is easy to recurse through\n  let keys = parse(keystr)\n  // Select the data from the source object or array\n  let data = select(src, keys)\n  // Return the data for further parsing\n  return data\n}\n\n// With a given source key array, select the corresponding value(s) in the source object/array.\n// If the value does not exist, return null\nfunction select(src, keys)\n{\n  // Get the object key or index that needs to be parsed\n  const key = keys.shift()\n\n  // The child entity is an array.  Traverse the array to obtain data\n  if (key.ix !== null && typeof key.ix !== 'undefined')\n    return select_arr(src, key, keys)\n\n  // The next instruction is an object key.  Try to obtain the data for the given object key\n  if (key.name)\n    return select_obj(src, key, keys)\n\n  // No data matching the instructions is found - return null\n  return null\n}\n\n// Loop through the array and select the key from each value in the array.  If nothing comes back, return null\nfunction select_arr(src, key, keys)\n{\n  let data = []\n\n  // The source is not an array even though we specify array.  Grab the subnode and add to an array.\n  if (!Array.isArray(src)) {\n    let d = null\n    // Try to get the next value in the chain.  If possible, then add to an array\n    if (keys.length)\n      d = select(src, keys)\n    // If we found something, return it as an array\n    return (d !== null) ? [ d ] : null\n  }\n\n  // Recursively loop through the array and grab the data\n  for (var i=0; i<src.length; i++) {\n    // Check to see if we are at a 'leaf' (no more keys to parse).  If so, return the data.  If not, recurse\n    var d = (keys.length) ? select(src[i], keys.slice()) : src[i]\n    // If the data is populated, add it to the array.  Make sure to keep the same array index so that traversing multi-level arrays work\n    if (d !== null)\n      data[i] = d\n  }\n\n  // Return the whole array if a specific index is not defined('') and there is data to return\n  if (key.ix == '' && data.length)\n    return data\n\n  // Return a specific node in the array if defined\n  if (key.ix && typeof negative_array_access(data, key.ix) !== 'undefined')\n    return negative_array_access(data, key.ix);\n\n  // If we are not expecting an array, return the first node - kinda hacky\n  if (typeof data[0] !== 'undefined' && key.name && data[0][key.name])\n    return data[0][key.name]\n  \n  // Otherwise, return nothing\n  return null\n}\n\n// Allows negative array indexes to count down from end of array\nfunction negative_array_access(arr, ix)\n{\n  var pix = parseInt(ix);\n  return pix < 0 ? arr[arr.length + pix] : arr[ix];\n}\n\n// Traverse the given object for data using the given key array\nfunction select_obj(src, key, keys)\n{\n  // Make sure that there is data where we are looking\n  if (src && key.name) {\n    \n    // Match all keys in the object\n    if (key.name == '*')\n      return select_obj_keys(src, keys)\n\n    // The key specifies an object.  However, the data structure is an array.  Grab the first node and continue\n    if (Array.isArray(src)) {\n      if (src.length && src[0])\n        return (keys.length) ? select(src[0][key.name], keys) : src[0][key.name]\n\n      return null\n    }\n\n    // The object has the given key\n    if (key.name in src) {\n      // There is data to be obtained\n      var data = (keys.length) ? select(src[key.name], keys) : src[key.name]\n      // If there is data return it\n      if (data !== null)\n        return data\n    }\n  }\n  // Otherwise, return nothing\n  return null\n}\n\n// Loop through all the keys in the object and select the key from each key in the object.  If nothing comes back, return null\nfunction select_obj_keys(src, keys)\n{\n  let data = []\n  let n=0\n  // Recursively loop through the object keys and grab the data\n  for (let k in src) {\n    // Check to see if we are at a 'leaf' (no more keys to parse).  If so, return the data.  If not, recurse\n    var d = (keys.length) ? select(src[k], keys.slice()) : src[k]\n    // If the data is populated, add it to the array\n    if (d !== null)\n      data[n++] = d\n  }\n\n  // Return the whole data array if there is data to return\n  if (data.length)\n    return data\n\n  // Otherwise, return nothing\n  return null\n}\n\n// The goal of this function is to identify the different ways that this function can be called, and to structure the data uniformly before caling update()\nfunction setKeyValue(dest, keystr, data, context = {})\n{\n  // Keystr is undefined - call set_data in case there is a default or transformation to deal with\n  if (typeof keystr == 'undefined' || keystr == null)\n    return set_data(dest, keystr, data, context)\n\n  // Keystr is an array of values.  Loop through each and identify what format the individual values are\n  if (Array.isArray(keystr)) {\n    for (let i=0; i<keystr.length; i++) {\n\n      // The substring value is in string notation - recurse with the key string\n      if (typeof keystr[i] == 'string')\n        dest = setKeyValue(dest, keystr[i], data, context)\n\n      // The subtring value is in array notation - recurse with the key from the array\n      else if (Array.isArray(keystr[i])) {\n        let [k,t,d] = keystr[i]\n        if (typeof t !== 'undefined') context.transform = t\n        if (typeof d !== 'undefined') context.default = d\n        dest = setKeyValue(dest, k, data, context)\n      }\n      \n      // The substring value is in object notation - dig further\n      else {\n        if (typeof keystr[i].transform !== 'undefined') context.transform = keystr[i].transform\n        if (typeof keystr[i].default !== 'undefined') context.default = keystr[i].default\n        \n        // If the substring value of the key is an array, parse the array.  If this is parsed in a recursion, it is confused with arrays containing multiple values\n        if (Array.isArray(keystr[i].key)) {\n          let [k,t,d] = keystr[i].key\n          if (typeof t !== 'undefined') context.transform = t\n          if (typeof d !== 'undefined') context.default = d\n          dest = setKeyValue(dest, k, data, context)\n        }\n        \n        // The substring value is regular object notation - recurse with the key of the substring\n        else\n          dest = setKeyValue(dest, keystr[i].key, data, context)\n      }\n    }\n  }\n\n  // The value is in string notation - ready for update!\n  else if (typeof keystr == 'string')\n    dest = update(dest, data, parse(keystr), context)\n\n  // The value is in object notation - dig a bit further\n  else {\n    if (typeof keystr.transform !== 'undefined') context.transform = keystr.transform\n    if (typeof keystr.default !== 'undefined') context.default = keystr.default\n    // If the value of the key is an array, parse the array.  If this is parsed in a recursion, it is confused with arrays containing multiple values\n    if (Array.isArray(keystr.key)) {\n      let [k,t,d] = keystr.key\n      if (typeof t !== 'undefined') context.transform = t\n      if (typeof d !== 'undefined') context.default = d\n      dest = setKeyValue(dest, k, data, context)\n    }\n    // The value is in regular object notation.  Recurse with the object key\n    else\n      dest = setKeyValue(dest, keystr.key, data, context)\n  }\n\n  return dest\n}\n\n// if the data is an array, walk down the obj path and build until there is an array key\nfunction update(dest, data, keys, context)\n{\n  if (keys) {\n    // Get the object key and index that needs to be parsed\n    const key = keys.shift()\n\n    // If there is a key, we need to traverse down to this part of the object\n    if (key.name)\n      return update_obj(dest, key, data, keys, context)\n\n    // If there is an array index, we need to traverse through the array\n    if (typeof key.ix !== 'undefined') {\n      return update_arr(dest, key, data, keys, context)\n    }\n  }\n\n  // If there is neither an array or index, we need to see if there is data to set\n  return set_data(dest, keys, data, context)\n}\n\n// Update the destination object.key with the data\nfunction update_obj(dest, key, data, keys, context)\n{\n  // There are further instructions remaining - we will need to recurse\n  if (keys.length) {\n    // There is a pre-existing destination object.  Recurse through to the object key\n    if (dest !== null && typeof dest !== 'undefined') {\n      let o = update(dest[key.name], data, keys, context)\n      if (o !== null && typeof o !== 'undefined')\n        dest[key.name] = o\n    }\n    // There is no pre-existing object.  Check to see if data exists before creating a new object\n    else {\n      // Check to see if there is a value before creating an object to store it\n      let o = update(null, data, keys, context)\n      if (o !== null) {\n        dest = {}\n        dest[key.name] = o\n      }\n    }\n  }\n  // This is a leaf.  Set data into the dest\n  else\n    dest = set_data(dest, key, data, context)\n\n  return dest\n}\n\n// Update the dest[] array with the data on each index\nfunction update_arr(dest, key, data, keys, context)\n{\n  // The 'add' instruction is set.  This means to take the data and add it onto a new array node \n  if (key.add) {\n    if (data !== null && typeof data !== 'undefined') {\n      dest = dest || []\n      dest.push(applyTransform(data,dest,context))\n      // dest = dest.concat(data)\n    }\n    return dest\n  }\n\n  // Just update a single array node\n  if (key.ix !== '') {\n    return update_arr_ix(dest, key.ix, applyTransform(data,dest,context), keys, context)\n  }\n\n  // If the data is in an array format then make sure that there is a dest index for each data index\n  if (Array.isArray(data)) {\n    dest = dest || []\n    // Loop through each index in the data array and update the destination object with the data\n    dest = data.reduce(function(dest,d,i) {\n      // If the instruction is to update all array indices ('') or the current index, update the child data element.  Otherwise, don't bother\n      if (key.ix == '' || key.ix == i) {\n        return update_arr_ix(dest, i, applyTransform(d,dest,context), keys.slice(), context)\n      }\n    }, dest)\n\n    return dest\n  }\n\n  // Set the specific array index with the data\n  else \n    return update_arr_ix(dest, '0', data, keys, context)\n}\n\nfunction applyTransform(data, dest, context){\n  if (typeof context.transform == 'function') {\n    return context.transform(data, context.src, dest, context.srckey, context.destkey)\n  }else{\n    return data;\n  }\n}\n\nfunction update_arr_ix(dest, ix, data, keys, context)\n{\n  let o\n  if (dest !== null && typeof dest !== 'undefined' && typeof dest[ix] !== 'undefined')\n    o = (keys.length) ? update(dest[ix], data, keys, context) : data\n  else\n    o = (keys.length) ? update(null, data, keys, context) : data\n\n  // Only update (and create if needed) dest if there is data to be saved\n  if (o !== null) {\n    dest = dest || []\n    dest[ix] = o\n  }\n\n  return dest\n}\n\n// Set the given data into the given destination object\nfunction set_data(dest, key, data, context)\n{\n  // If there is a transformation function, call the function.\n  if (typeof context.transform == 'function') {\n    dest = dest || {}\n    data = context.transform(data, context.src, dest, context.srckey, context.destkey)\n  }\n\n  // See if data is null and there is a default\n  if (typeof context.default !== 'undefined' && (data == null || typeof data == 'undefined')) {\n    // There is a default function, call the function to set the default\n    if (typeof context.default == 'function') {\n      dest = dest || {}\n      data = context.default(context.src, context.srckey, dest, context.destkey)\n    }\n    // The default is a specific value\n    else\n      data = context.default\n  }\n\n  // Set the object to the data if it is not undefined\n  if (typeof data !== 'undefined' && key && key.name) {\n    // Set the data if the data is not null, or if the 'allow nulls' key is set, or if there is a default (in the case of default=null, make sure to write this out)\n    if (data !== null || key.nulls || (typeof context.default !== 'undefined' && context.default == null)) {\n      dest = dest || {}\n      dest[key.name] = data\n    }\n  }\n\n  // Return the dest variable back to the caller.\n  return dest\n}\n\n\n// Turns a key string (like key1.key2[].key3 into ['key1','key2','[]','key3']...)\n// \nfunction parse(key_str, delimiter = '.')\n{\n  // Return null if the key_str is null\n  if (key_str == null)\n    return null\n\n  // Split the key_array and allowing escapes\n  const key_arr = split(key_str, delimiter)\n  //const key_arr = key_str.split(delimiter)\n  let keys = []\n  let n = 0\n  for (let i=0; i<key_arr.length; i++) {\n    // Build a object which is either an object key or an array\n    //  Note that this is not the most readable, but it is fastest way to parse the string (at this point in time)\n    let name_begin=-1, name_end=-1, ix_begin=-1, ix_end=-1, o = {}, a = {}, k = key_arr[i]\n    for (let j=0; j<k.length; j++) {\n      switch (k[j]) {\n        case '[' :\n          ix_begin = j+1\n          name_end = j\n          break\n        case ']' :\n          ix_end = j\n          break\n        case '+' :\n          if (ix_end == j-1) a.add = true\n          break\n        case '?' :\n          name_end = j\n          if (ix_end == -1) o.nulls = true\n          break\n        default :\n          if (ix_begin == -1) name_end = j+1\n      }\n    }\n    if (name_end > 0) {\n      o.name = k.substring(name_begin, name_end)\n      keys[n++] = o\n    }\n    if (ix_end > 0) {\n      a.ix = k.substring(ix_begin, ix_end)\n      keys[n++] = a\n    }\n  }\n\n  return keys\n} \n\n// Perform the same function as split(), but keep track of escaped delimiters\nfunction split(str, delimiter)\n{\n  let arr = [], n = 0\n  , esc = -99\n  , s = ''\n\n  for (let i=0; i<str.length; i++) {\n    switch(str[i]) {\n      case delimiter :\n        if (esc !== (i-1)) {\n          arr[n++] = s\n          s = ''\n        } else s += str[i]\n        break\n      case '\\\\' :\n        // Escaping a backslash\n        if (esc == (i-1)) {\n          esc = -99\n          s += str[i-1] + str[i]\n        } else \n          esc = i\n        break\n      default :\n        if (esc == (i-1))\n          s += str[i-1]\n        s += str[i]\n    }\n  }\n  arr[n++] = s\n  return arr\n}\n\nmodule.exports = ObjectMapper\nmodule.exports.merge = ObjectMapper\nmodule.exports.getKeyValue = getKeyValue\nmodule.exports.setKeyValue = setKeyValue\nmodule.exports.parse = parse\nmodule.exports.split = split\n","import { db } from \"@app/database\";\r\nimport deepmerge from \"deepmerge\";\r\nimport { proxy } from \"comlink\";\r\nimport { merge } from \"object-mapper\";\r\nexport interface Ident {\r\n    rootId?: string\r\n    id: string\r\n    type: string\r\n}\r\nexport interface MetaData {\r\n    alternativeIds: Record<string, string>\r\n    source: string\r\n    progenitor?: string\r\n    enabled: boolean\r\n    flags: Record<string, any>\r\n}\r\nexport type TypeCollection = Record<string, Data[]>\r\nexport interface Data extends Record<string, any>, Ident {\r\n    version: number\r\n    categories: string[]\r\n    name: string\r\n    children: TypeCollection\r\n    features: any[]\r\n    config?: Record<string, any>\r\n    metadata: MetaData\r\n}\r\nexport class Entity<V extends Data, R extends Data = V> {\r\n    value: V\r\n    root: R\r\n    constructor(value: V, root?: R) {\r\n        this.value = value;\r\n        this.root = root || value as unknown as R;\r\n    }\r\n    get enabled() {\r\n        return this?.value?.metadata?.enabled\r\n    }\r\n    get id() {\r\n        return this.value?.id\r\n    }\r\n    get type() {\r\n        return this?.value?.type\r\n    }\r\n    getType() {\r\n        console.log(\"GETTING TYPE\");\r\n        return this.type\r\n    }\r\n    getValue() {\r\n        console.log(\"GETTING VALUE\");\r\n        return this.value\r\n    }\r\n    private static hashEmbedded<R extends Data = Data>(root: R, start: Data = root, maxDepth = Number.POSITIVE_INFINITY) {\r\n        let currentDepth: number = 0;\r\n        const embeds: Record<string, Entity<Data, R>> = {};\r\n        function descend(data: Data) {\r\n            const { children = {} } = data || {};\r\n            for (const [type, data] of Object.entries(children)) {\r\n                for (const child of data) {\r\n                    embeds[child.id] = new Entity<Data, R>(child, root);\r\n                    if (currentDepth++ > maxDepth) descend(child);\r\n                }\r\n            }\r\n        }\r\n        descend(start);\r\n        return embeds;\r\n    }\r\n    getRootEmbeds() {\r\n        return Entity.hashEmbedded(this.root);\r\n    }\r\n    getEmbeds() {\r\n        return Entity.hashEmbedded(this.root, this.value);\r\n    }\r\n    getEmbedded(id: string) {\r\n        return Entity.hashEmbedded(this.root, this.value)[id];\r\n    }\r\n    getChildren() {\r\n        return Entity.hashEmbedded(this.root, this.value, 1);\r\n    }\r\n    getFeatures() {\r\n        const root = new Entity<R>(this.root);\r\n        const embedded = root.getRootEmbeds();\r\n        const activeEmbeds: Entity<Data, R>[] = Object.values(embedded).filter(entity => !!entity.enabled)\r\n        const features = activeEmbeds.flatMap(entity => entity.value.features).filter(v => !!v);\r\n        return features\r\n    }\r\n    async update(value) { }\r\n    async set(value) {\r\n        this.update(value);\r\n    }\r\n    subscribe() { }\r\n    unsubscribe() { }\r\n    map(typeMap, nestfunc) {\r\n        const nodes = this.getEmbeds();\r\n        const transformed = {};\r\n        for (const [id, entity] of Object.entries(nodes)) {\r\n            const map = typeMap[entity.type];\r\n            if (!map) continue;\r\n            transformed[id] = merge(entity.value, map);\r\n        }\r\n    }\r\n}","import { Data, Entity } from \"@app/entity\";\r\nimport { CharacterData } from \"./character\";\r\nexport interface TraitModifierData {\r\n    type: \"trait\"\r\n    enabled: boolean\r\n    name: string\r\n    cost: number,\r\n    costType: TraitModifierType\r\n    levels: number\r\n    hasLevels: boolean\r\n    affects: TraitModifierAffects\r\n}\r\nexport enum ControlRating {\r\n    CannotResist = \"none\",\r\n    ResistRarely = 6,\r\n    ResistFairlyOften = 9,\r\n    ResistQuiteOften = 12,\r\n    ResistAlmostAlway = 15,\r\n    NoneRequired = \"n/a\"\r\n}\r\nexport enum TraitModifierType {\r\n    Percentage = \"percentage\",\r\n    Points = \"points\",\r\n    Multiplier = \"multiplier\",\r\n}\r\nexport enum TraitModifierAffects {\r\n    Base = \"base only\",\r\n    Levels = \"levels only\",\r\n    Total = \"total\"\r\n}\r\nexport enum TraitType {\r\n    Mental = \"Mental\",\r\n    Physical = \"Physical\",\r\n    Social = \"Social\",\r\n    Exotic = \"Exotic\",\r\n}\r\nexport interface TraitData extends Data {\r\n    version__: typeof Trait[\"version\"]\r\n    type: typeof Trait[\"type\"]\r\n    basePoints: number\r\n    hasLevels: boolean\r\n    levels: number\r\n    pointsPerLevel: number\r\n    allowHalfLevel: boolean\r\n    hasHalfLevel: boolean\r\n    roundDown: boolean\r\n    controlRating: ControlRating\r\n    types: TraitType[]\r\n    modifiers: TraitModifierData[]\r\n}\r\n\r\nexport class Trait extends Entity<TraitData, CharacterData> {\r\n    static version = 1\r\n    static type = \"trait\"\r\n    constructor(value, root) {\r\n        super(value, root);\r\n    }\r\n    getAdjustedPoints() {\r\n        return calculateTraitCost(this.value);\r\n    }\r\n    getTraitType() {\r\n        return getTraitType(this.value);\r\n    }\r\n}\r\n\r\nexport function calculateTraitCost(\r\n    {\r\n        basePoints,\r\n        hasLevels,\r\n        levels,\r\n        hasHalfLevel,\r\n        roundDown,\r\n        controlRating,\r\n        pointsPerLevel,\r\n        modifiers\r\n    }: TraitData\r\n) {\r\n    let baseEnh = 0;\r\n    let levelEnh = 0;\r\n    let baseLim = 0;\r\n    let levelLim = 0;\r\n    let multiplier = getControlRatingMultipland(controlRating);\r\n\r\n    modifiers?.forEach(modifier => {\r\n        if (modifier.enabled) {\r\n            let mod = costModifier(modifier);\r\n            switch (modifier.costType) {\r\n                case TraitModifierType.Percentage:\r\n                default:\r\n                    switch (modifier.affects) {\r\n                        case TraitModifierAffects.Total:\r\n                        default:\r\n                            if (mod < 0) {\r\n                                baseLim += mod;\r\n                                levelLim += mod;\r\n                            } else {\r\n                                baseEnh += mod;\r\n                                levelEnh += mod;\r\n                            }\r\n                            break\r\n                        case TraitModifierAffects.Base:\r\n                            if (mod < 0) {\r\n                                baseLim += mod;\r\n                            } else {\r\n                                baseEnh += mod;\r\n                            }\r\n                            break\r\n                        case TraitModifierAffects.Levels:\r\n                            if (mod < 0) {\r\n                                levelLim += mod;\r\n                            } else {\r\n                                levelEnh += mod;\r\n                            }\r\n                            break\r\n                    }\r\n                    break\r\n                case TraitModifierType.Points:\r\n                    switch (modifier.affects) {\r\n                        case TraitModifierAffects.Total:\r\n                        case TraitModifierAffects.Base:\r\n                        default:\r\n                            basePoints += mod;\r\n                            break\r\n                        case TraitModifierAffects.Levels:\r\n                            pointsPerLevel += mod;\r\n                            break\r\n                    }\r\n                    break\r\n                case TraitModifierType.Multiplier:\r\n                    multiplier *= mod;\r\n                    break\r\n            }\r\n        }\r\n    });\r\n\r\n    let modifiedBasePoints = basePoints;\r\n\r\n    let leveledPoints =\r\n        hasLevels ?\r\n            pointsPerLevel * (levels + (hasHalfLevel ? .5 : 0)) || 0\r\n            : 0;\r\n    if (baseEnh !== 0 || baseLim !== 0 || levelEnh !== 0 || levelLim !== 0) {\r\n        if (false) {\r\n            //TODO multiplicative modifiers\r\n        } else {\r\n            let baseMod = Math.max(baseEnh + baseLim, -80);\r\n            let levelMod = Math.max(levelEnh + levelLim, -80);\r\n\r\n            modifiedBasePoints = baseMod === levelMod ?\r\n                modifyPoints((modifiedBasePoints + leveledPoints), baseMod) :\r\n                modifyPoints(modifiedBasePoints, baseMod) + modifyPoints(leveledPoints, levelMod);\r\n        }\r\n    } else {\r\n        modifiedBasePoints += (leveledPoints);\r\n    }\r\n    return applyRounding((modifiedBasePoints * multiplier), Boolean(roundDown)) || 0\r\n}\r\n\r\nfunction getControlRatingMultipland(cr: ControlRating) {\r\n    switch (cr) {\r\n        case ControlRating.CannotResist: return 2.5\r\n        case ControlRating.ResistRarely: return 2\r\n        case ControlRating.ResistFairlyOften: return 1.5\r\n        case ControlRating.ResistQuiteOften: return 1\r\n        case ControlRating.ResistAlmostAlway: return 0.5\r\n        default: return 1\r\n    }\r\n}\r\n\r\nexport function costModifier(modifier: TraitModifier) {\r\n    return modifier.hasLevels && modifier.levels > 0 ? modifier.cost * modifier.levels : modifier.cost\r\n}\r\n\r\nexport function modifyPoints(points: number, modifier: number) { return points + calculateModifierPoints(points, modifier); }\r\nexport function calculateModifierPoints(points: number, modifier: number) { return points * (modifier / 100) }\r\nexport function applyRounding(value: number, roundCostDown: boolean) { return roundCostDown ? Math.floor(value) : Math.ceil(value) }\r\n\r\nexport interface TraitModifier {\r\n    enabled: boolean\r\n    cost: number,\r\n    costType: TraitModifierType\r\n    levels: number\r\n    affects: TraitModifierAffects\r\n    hasLevels: boolean\r\n}\r\n\r\nexport enum TraitCategory {\r\n    Advantage = \"advantage\",\r\n    Perk = \"perk\",\r\n    Disadavantage = \"disadvantage\",\r\n    Quirk = \"quirk\",\r\n    Feature = \"feature\",\r\n    Racial = \"racial\",\r\n    Meta = \"meta\",\r\n    Language = \"language\",\r\n    Culture = \"culture\",\r\n    Never = -1\r\n}\r\n\r\nexport function isAdvantage(trait: TraitData) {\r\n    return trait.basePoints > 1\r\n        || trait.pointsPerLevel > 1\r\n        || calculateTraitCost(trait) > 1\r\n}\r\nexport function isPerk(trait: TraitData) {\r\n    return (trait.basePoints === 1 || !trait.basePoints)\r\n        && (trait.hasLevels ? trait.pointsPerLevel === 1 : true)\r\n        && calculateTraitCost(trait) !== 0\r\n}\r\nexport function isDisadvantage(trait: TraitData) {\r\n    return trait.basePoints < -1\r\n        || trait.pointsPerLevel < -1\r\n        || calculateTraitCost(trait) < -1\r\n}\r\nexport function isQuirk(trait: TraitData) {\r\n    return (trait.basePoints === -1 || !trait.basePoints)\r\n        && (trait.hasLevels ? trait.pointsPerLevel === -1 : true)\r\n        && calculateTraitCost(trait) !== 0\r\n}\r\nexport function isFeature(trait: TraitData) {\r\n    return !trait.basePoints\r\n        && !trait.pointsPerLevel\r\n        && calculateTraitCost(trait) === 0\r\n}\r\n\r\nexport function getCategory(tags: string[]) {\r\n    const categories = tags.join(' ');\r\n    if (/meta/i.test(categories)) return TraitCategory.Meta\r\n    if (/racial/i.test(categories)) return TraitCategory.Racial\r\n    if (/quirk/i.test(categories)) return TraitCategory.Quirk\r\n    if (/disadvantage/i.test(categories)) return TraitCategory.Disadavantage\r\n    if (/perk/i.test(categories)) return TraitCategory.Perk\r\n    if (/advantage/i.test(categories)) return TraitCategory.Advantage\r\n    if (/feature/i.test(categories)) return TraitCategory.Feature\r\n    return -1\r\n}\r\n\r\nexport function getContainerType(traits: TraitData[]) {\r\n    let racial = false;\r\n    let perk = false;\r\n    let advantage = false;\r\n    let quirk = false;\r\n    let disadvantage = false;\r\n    let feature = false;\r\n\r\n    // iterate once over the children and gather the information we need to determine the type\r\n    let types = traits.map(child => {\r\n        let type = getTraitType(child);\r\n        switch (type) {\r\n            case TraitCategory.Racial: racial = true; break;\r\n            case TraitCategory.Perk: perk = true; break;\r\n            case TraitCategory.Advantage: advantage = true; break;\r\n            case TraitCategory.Quirk: quirk = true; break;\r\n            case TraitCategory.Disadavantage: disadvantage = true; break;\r\n            case TraitCategory.Feature: feature = true; break;\r\n        }\r\n        return type\r\n    });\r\n\r\n    // no need to check for all conditions, they couldn't show up if the previous one returns\r\n    if (!types.some(type => type !== TraitCategory.Racial)) return TraitCategory.Racial;\r\n    if (!types.some(type => type !== TraitCategory.Advantage)) return TraitCategory.Advantage;\r\n    if (!types.some(type => type !== TraitCategory.Perk)) return TraitCategory.Perk;\r\n    if (!types.some(type => type !== TraitCategory.Disadavantage)) return TraitCategory.Disadavantage;\r\n    if (!types.some(type => type !== TraitCategory.Quirk)) return TraitCategory.Quirk;\r\n    if (!types.some(type => type !== TraitCategory.Feature)) return TraitCategory.Feature;\r\n\r\n    // if we don't have a homogenous container put it into meta traits\r\n    if (!advantage && !perk && (disadvantage || quirk)) return TraitCategory.Disadavantage\r\n    if (!disadvantage && !quirk && (advantage || perk)) return TraitCategory.Advantage\r\n    return TraitCategory.Meta;\r\n}\r\n\r\nexport function getTraitType(trait: TraitData) {\r\n    if (!trait) return TraitCategory.Never;\r\n    const { categories } = trait;\r\n    const children = (trait?.children?.trait ?? []) as TraitData[]\r\n    let type = getCategory(categories);\r\n    if (children.length > 0) {\r\n        return getContainerType(children)\r\n    }\r\n    if (type !== TraitCategory.Never) return type\r\n    const advantage = isAdvantage(trait);\r\n    const perk = isPerk(trait);\r\n    const disadvantage = isDisadvantage(trait);\r\n    const quirk = isQuirk(trait);\r\n    const feature = isFeature(trait);\r\n    if (disadvantage) return TraitCategory.Disadavantage;\r\n    if (quirk) return TraitCategory.Quirk;\r\n    if (advantage) return TraitCategory.Advantage;\r\n    if (perk) return TraitCategory.Perk;\r\n    if (feature) return TraitCategory.Feature;\r\n    type = TraitCategory.Meta;\r\n    return type\r\n}\r\n\r\nexport function split(traits: TraitData[]) {\r\n    if (!traits) return {}\r\n    const splits = {\r\n        [TraitCategory.Advantage]: traits.filter(trait => getTraitType(trait) === TraitCategory.Advantage),\r\n        [TraitCategory.Disadavantage]: traits.filter(trait => getTraitType(trait) === TraitCategory.Disadavantage),\r\n        [TraitCategory.Racial]: traits.filter(trait => getTraitType(trait) === TraitCategory.Racial),\r\n        [TraitCategory.Meta]: traits.filter(trait => getTraitType(trait) === TraitCategory.Meta),\r\n        [TraitCategory.Perk]: traits.filter(trait => getTraitType(trait) === TraitCategory.Perk),\r\n        [TraitCategory.Quirk]: traits.filter(trait => getTraitType(trait) === TraitCategory.Quirk),\r\n        [TraitCategory.Feature]: traits.filter(trait => getTraitType(trait) === TraitCategory.Feature)\r\n    };\r\n    return removeDuplicates(splits);\r\n}\r\n\r\nexport function sumTraitArray(traits: TraitData[]) {\r\n    return traits?.reduce((total, trait) => calculateTraitCost(trait) + total, 0) ?? 0\r\n}\r\n\r\n/**\r\n * Reducing Algorithm to remove duplicates from derived lists. Any item that appears\r\n * in the list later on, based on the order of the keys. Things earlier in the lists will\r\n * be overridden by things later in the list. Be sure to account for that when using this function.\r\n * @param lists A series of lists to remove the duplicates from\r\n */\r\nexport function removeDuplicates<T extends { id: string }>(lists: { [key: string]: T[] }) {\r\n    const checked = new Set();\r\n    return Object.entries(lists).reduce((prev, [type, list]) => {\r\n        checked.add(type);\r\n        const checkAgainst = Object.entries(lists)\r\n            .filter(([key1, list]) => {\r\n                type !== key1 && !checked.has(key1)\r\n            })\r\n            .flatMap(values => values[1])\r\n            .map(list => list.id);\r\n        let newCollection = list.filter(item => !checkAgainst.includes(item.id));\r\n        prev[type] = newCollection;\r\n        return prev\r\n    }, {} as Record<string, T[]>)\r\n}","import { expose } from \"comlink\";\r\nimport { Trait } from \"../resources/trait\";\r\nself[\"onconnect\"] = e => expose(Trait, e.ports[0])"],"sourceRoot":""}