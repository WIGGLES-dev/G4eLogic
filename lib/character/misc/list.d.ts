import { Character, Featurable } from "../character";
import { CharacterElement } from "./element";
import { Feature } from "./feature";
import { Weapon } from "../weapon";
import { json } from "@utils/json_utils";
export declare abstract class ListItem<T extends Featurable> extends CharacterElement<T> {
    #private;
    static keys: any[];
    abstract version: number;
    abstract tag: string;
    abstract name: string;
    list: List<T>;
    canContainChildren: boolean;
    children: Set<ListItem<T>>;
    isContained: boolean;
    containedBy: T;
    features: Set<Feature<T>>;
    weapons: Set<Weapon<T>>;
    constructor(list: List<T>, keys: string[]);
    abstract isActive(): boolean;
    addFeature(): void;
    addWeapon(type?: string): Weapon<T>;
    getListDepth(): number;
    getCharacter(): Character;
    isContainer(): boolean;
    iterChildren(): ListItem<T>[];
    addChild(child?: T): T;
    removeChild(child: string | T): void;
    getRecursiveChildren(): void;
    findSelf(): T;
    delete(): void;
    private loadChildren;
    load<U>(data: any): T;
    save(): any;
}
export declare abstract class List<T extends Featurable> {
    #private;
    contents: Set<T>;
    character: Character;
    constructor(character: Character);
    get length(): number;
    get [Symbol.iterator](): () => IterableIterator<T>;
    abstract populator(data: any): T;
    generate(): void;
    addListItem(item?: T | ListItem<T>, data?: any): T;
    removeListItem(item: T): void;
    getByIndex(index: number): T;
    getByUUID(uuid: string): T;
    getSize(): number;
    iter(): T[];
    iterTop(): T[];
    keys(): T[];
    save(): any;
    load(data: string | json): List<any>;
    empty(): void;
}
